To achieve separate ViewModels for each view in your application, you need to create a ViewModel for each control (PatientRegControl, AppointmentConfirmationControl, and PatientDashboardControl). Each ViewModel should encapsulate the data and logic specific to the UserControl it’s intended to work with, leaving the code-behind files (.xaml.cs) as empty as possible. Below is an updated structure that accomplishes this separation.

### Updated ViewModels

1. **PatientRegViewModel** - Manages registration-related data and actions.
2. **AppointmentConfirmationViewModel** - Manages appointment confirmation data and actions.
3. **PatientDashboardViewModel** - Manages dashboard-related data.

### Updated Code

---

#### PatientRegViewModel.cs
```csharp
using System;
using System.ComponentModel;
using System.Windows.Input;

namespace PatientApp
{
    public class PatientRegViewModel : INotifyPropertyChanged
    {
        public event PropertyChangedEventHandler PropertyChanged;
        public event EventHandler RegistrationCompleted;
        public event EventHandler NavigateToAppointment;

        private Patient _patient;
        public Patient Patient
        {
            get => _patient;
            set
            {
                _patient = value;
                OnPropertyChanged(nameof(Patient));
            }
        }

        public ICommand RegisterCommand { get; }

        public PatientRegViewModel()
        {
            Patient = new Patient();
            RegisterCommand = new RelayCommand(RegisterPatient);
        }

        private void RegisterPatient(object parameter)
        {
            // Implement validation and registration logic here
            RegistrationCompleted?.Invoke(this, EventArgs.Empty);
            NavigateToAppointment?.Invoke(this, EventArgs.Empty);
        }

        private void OnPropertyChanged(string propertyName)
        {
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
        }
    }
}
```

#### AppointmentConfirmationViewModel.cs
```csharp
using System;
using System.Collections.ObjectModel;
using System.ComponentModel;

namespace PatientApp
{
    public class AppointmentConfirmationViewModel : INotifyPropertyChanged
    {
        public event PropertyChangedEventHandler PropertyChanged;
        public event EventHandler AppointmentCompleted;
        public event EventHandler NavigateToDashboard;

        public ObservableCollection<Patient> Patients { get; }
        public ObservableCollection<Patient> ConfirmedPatients { get; }

        public AppointmentConfirmationViewModel(ObservableCollection<Patient> patients)
        {
            Patients = patients;
            ConfirmedPatients = new ObservableCollection<Patient>();
        }

        public void ConfirmAppointments()
        {
            foreach (var patient in Patients)
            {
                ConfirmedPatients.Add(patient);
            }
            AppointmentCompleted?.Invoke(this, EventArgs.Empty);
            NavigateToDashboard?.Invoke(this, EventArgs.Empty);
        }

        private void OnPropertyChanged(string propertyName)
        {
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
        }
    }
}
```

#### PatientDashboardViewModel.cs
```csharp
using System.Collections.ObjectModel;
using System.ComponentModel;

namespace PatientApp
{
    public class PatientDashboardViewModel : INotifyPropertyChanged
    {
        public event PropertyChangedEventHandler PropertyChanged;

        public ObservableCollection<Patient> ConfirmedPatients { get; }

        public PatientDashboardViewModel(ObservableCollection<Patient> confirmedPatients)
        {
            ConfirmedPatients = confirmedPatients;
        }

        private void OnPropertyChanged(string propertyName)
        {
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
        }
    }
}
```

---

### Updating MainWindow.xaml.cs

MainWindow.xaml.cs should now only instantiate each ViewModel and set the DataContext for each UserControl.

```csharp
public partial class MainWindow : Window
{
    private readonly PatientViewModel _mainViewModel;
    private readonly PatientRegViewModel _patientRegViewModel;
    private readonly AppointmentConfirmationViewModel _appointmentConfirmationViewModel;
    private readonly PatientDashboardViewModel _dashboardViewModel;

    public MainWindow()
    {
        InitializeComponent();

        _mainViewModel = new PatientViewModel();
        _patientRegViewModel = new PatientRegViewModel();
        _appointmentConfirmationViewModel = new AppointmentConfirmationViewModel(_mainViewModel.Patients);
        _dashboardViewModel = new PatientDashboardViewModel(_appointmentConfirmationViewModel.ConfirmedPatients);

        _patientRegViewModel.RegistrationCompleted += OnRegistrationCompleted;
        _patientRegViewModel.NavigateToAppointment += (s, e) => MainContent.Content = new AppointmentConfirmationControl { DataContext = _appointmentConfirmationViewModel };
        _appointmentConfirmationViewModel.AppointmentCompleted += (s, e) => MainContent.Content = null;
        _appointmentConfirmationViewModel.NavigateToDashboard += (s, e) => MainContent.Content = new PatientDashboardControl { DataContext = _dashboardViewModel };
    }

    private void btnRegistration_Click(object sender, RoutedEventArgs e)
    {
        MainContent.Content = new PatientRegControl { DataContext = _patientRegViewModel };
    }

    private void btnAppointment_Click(object sender, RoutedEventArgs e)
    {
        MainContent.Content = new AppointmentConfirmationControl { DataContext = _appointmentConfirmationViewModel };
    }

    private void btnDashboard_Click(object sender, RoutedEventArgs e)
    {
        MainContent.Content = new PatientDashboardControl { DataContext = _dashboardViewModel };
    }

    private void OnRegistrationCompleted(object sender, EventArgs e)
    {
        MainContent.Content = null;
    }
}
```

---

### RelayCommand.cs

A simple RelayCommand class is required for implementing ICommand for command bindings.

```csharp
using System;
using System.Windows.Input;

namespace PatientApp
{
    public class RelayCommand : ICommand
    {
        private readonly Action<object> _execute;
        private readonly Predicate<object> _canExecute;

        public RelayCommand(Action<object> execute, Predicate<object> canExecute = null)
        {
            _execute = execute ?? throw new ArgumentNullException(nameof(execute));
            _canExecute = canExecute;
        }

        public bool CanExecute(object parameter) => _canExecute?.Invoke(parameter) ?? true;

        public void Execute(object parameter) => _execute(parameter);

        public event EventHandler CanExecuteChanged
        {
            add => CommandManager.RequerySuggested += value;
            remove => CommandManager.RequerySuggested -= value;
        }
    }
}
```

---

This setup keeps your `MainWindow.xaml.cs` file clean, with all logic moved into individual ViewModels for each UserControl, and allows you to bind the DataContext of each UserControl directly. Each ViewModel now handles its respective control’s data and logic, ensuring separation of concerns.
