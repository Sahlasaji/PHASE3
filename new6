To restructure the application so that all logic resides in separate ViewModel classes (one per UserControl) and the `.cs` files of UserControls and MainWindow remain code-free, you can follow these steps:

---

### **1. Create Separate ViewModels**
Create a new ViewModel for each UserControl and use `RelayCommand` for handling commands. All properties, event handling, and logic should reside in these ViewModels.

---

#### **RelayCommand Implementation**
Create a generic `RelayCommand` class to simplify command handling:

```csharp
using System;
using System.Windows.Input;

namespace PatientApp
{
    public class RelayCommand : ICommand
    {
        private readonly Action<object> _execute;
        private readonly Predicate<object> _canExecute;

        public RelayCommand(Action<object> execute, Predicate<object> canExecute = null)
        {
            _execute = execute;
            _canExecute = canExecute;
        }

        public bool CanExecute(object parameter) => _canExecute == null || _canExecute(parameter);

        public void Execute(object parameter) => _execute(parameter);

        public event EventHandler CanExecuteChanged
        {
            add => CommandManager.RequerySuggested += value;
            remove => CommandManager.RequerySuggested -= value;
        }
    }
}
```

---

### **2. Refactor MainViewModel**
Create a `MainViewModel` to manage navigation and share data between child ViewModels.

```csharp
using System.ComponentModel;
using System.Windows.Input;

namespace PatientApp
{
    public class MainViewModel : INotifyPropertyChanged
    {
        private object _currentViewModel;

        public object CurrentViewModel
        {
            get => _currentViewModel;
            set
            {
                _currentViewModel = value;
                OnPropertyChanged(nameof(CurrentViewModel));
            }
        }

        public ICommand ShowRegistrationCommand { get; }
        public ICommand ShowAppointmentCommand { get; }
        public ICommand ShowDashboardCommand { get; }

        public PatientViewModel PatientViewModel { get; }

        public MainViewModel()
        {
            PatientViewModel = new PatientViewModel();
            ShowRegistrationCommand = new RelayCommand(_ => CurrentViewModel = new PatientRegViewModel(PatientViewModel));
            ShowAppointmentCommand = new RelayCommand(_ => CurrentViewModel = new AppointmentConfirmationViewModel(PatientViewModel));
            ShowDashboardCommand = new RelayCommand(_ => CurrentViewModel = new PatientDashboardViewModel(PatientViewModel));
        }

        public event PropertyChangedEventHandler PropertyChanged;
        protected void OnPropertyChanged(string propertyName)
        {
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
        }
    }
}
```

---

### **3. Create Child ViewModels**

#### PatientRegViewModel
```csharp
using System.Windows.Input;

namespace PatientApp
{
    public class PatientRegViewModel
    {
        public PatientViewModel PatientViewModel { get; }
        public ICommand RegisterCommand { get; }

        public PatientRegViewModel(PatientViewModel patientViewModel)
        {
            PatientViewModel = patientViewModel;
            RegisterCommand = new RelayCommand(RegisterPatient);
        }

        private void RegisterPatient(object parameter)
        {
            // Registration logic here
        }
    }
}
```

#### AppointmentConfirmationViewModel
```csharp
using System.Windows.Input;

namespace PatientApp
{
    public class AppointmentConfirmationViewModel
    {
        public PatientViewModel PatientViewModel { get; }
        public ICommand ConfirmCommand { get; }

        public AppointmentConfirmationViewModel(PatientViewModel patientViewModel)
        {
            PatientViewModel = patientViewModel;
            ConfirmCommand = new RelayCommand(ConfirmAppointments);
        }

        private void ConfirmAppointments(object parameter)
        {
            // Confirmation logic here
        }
    }
}
```

#### PatientDashboardViewModel
```csharp
namespace PatientApp
{
    public class PatientDashboardViewModel
    {
        public PatientViewModel PatientViewModel { get; }

        public PatientDashboardViewModel(PatientViewModel patientViewModel)
        {
            PatientViewModel = patientViewModel;
        }
    }
}
```

---

### **4. Refactor XAML for Binding**

#### MainWindow.xaml
Bind `ContentControl` to `CurrentViewModel`:

```xml
<Window.DataContext>
    <local:MainViewModel/>
</Window.DataContext>

<ContentControl Content="{Binding CurrentViewModel}" />
<Button Content="Register Patient" Command="{Binding ShowRegistrationCommand}" />
<Button Content="Appointment Confirmation" Command="{Binding ShowAppointmentCommand}" />
<Button Content="Patient Dashboard" Command="{Binding ShowDashboardCommand}" />
```

#### UserControls
Bind `DataContext` to respective ViewModels in XAML:

- **PatientRegControl.xaml:**
```xml
<UserControl.DataContext>
    <local:PatientRegViewModel/>
</UserControl.DataContext>
<Button Content="Register" Command="{Binding RegisterCommand}" />
```

- **AppointmentConfirmationControl.xaml:**
```xml
<UserControl.DataContext>
    <local:AppointmentConfirmationViewModel/>
</UserControl.DataContext>
<Button Content="Confirm" Command="{Binding ConfirmCommand}" />
```

- **PatientDashboardControl.xaml:**
```xml
<UserControl.DataContext>
    <local:PatientDashboardViewModel/>
</UserControl.DataContext>
```

---

### **5. Remove Logic from `.cs` Files**
All logic is moved to ViewModels. The `.cs` files will only initialize the `DataContext` if not already bound in XAML.

---

### **Summary of Changes**
- `RelayCommand` simplifies command handling.
- MainWindow and UserControls are logic-free.
- ViewModels handle all logic and command interactions.
- Navigation logic moved to `MainViewModel`.

This approach adheres to MVVM principles and keeps `.cs` files clean while maintaining your existing functionality.
